* 思路
** 朴素解法
   遍历 nums1，在 nums2 中找到对应的下标，从下标往后遍历 nums2, 找到第一个比当前数字大的数。

   时间复杂度是 O(mn)

** 单调栈
   在 nums2 中找到第一个最大值，其实有一些重复操作，如果可以先处理 nums2,
   把 nums2 每个元素对应的第一个比它大的值先计算出来，当从 nums1 中遍历，就能直接返回了。

   由于 nums2 的元素都是不相同的，可以用一个 map 存储每个元素对应的比自己大的值。

   从后往前遍历，利用一个单调栈，从栈底到栈顶单调递减。

   这个单调栈维护了当前元素右边的可能比它大的值，对于当前元素，去和单调栈的栈顶元素比较，如果当前元素比栈顶大，
   则栈顶出栈，和下一个更大的栈顶比较。如果比较到栈为空，都没有找到更大的元素，则表示右边没有比当前元素更大的。

   如果栈内存在一个元素比当前元素大，那么这个元素，就是当前元素对应的第一个比它大的值。
* 参考
  - [[https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/][下一个更大元素 I]]
