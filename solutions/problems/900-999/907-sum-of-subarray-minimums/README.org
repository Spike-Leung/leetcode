* 思路
一开始没有什么思路，先从最容易，最朴素的方法开始尝试：

只要找到所有的连续子数组，找到子数组的最小值，再累计总和即可，但是需要双重遍历，时间复杂度 O(n ^ 2)

观察双重遍历的过程，可以发现一个特点，例如对于数组 arr = [2,3,1,2,6], arr[2] = 1, 只要子数组包含 arr[2] 这个元素，那么最小值都是 arr[2]

于是可以反过来思考，考虑 arr[2] 作为最小值，可以构成多少个子数组？假如可以构成 X 个，那么，以 arr[2] 为最小值所有子数组的和即为 X * arr[2]

同理，可以遍历一边数组，找到以每一个元素作为最小值，可以构成多少子数组，统计所有元素构成子数组的和就是答案。

接下来就考虑，如何找到以每个元素作为最小值，构成的子数组数量。

以 arr = [7,1,3,4,2,5,9] 为例，对于 arr[5] (值为 2), 往左和往右扩展，只要没有比 2 小的，那么在这个范围内，2 就是这个范围的最小值

对应就是 [3,4,2,5,9] 这一段，对于这一段，选择一个范围，左边界可以从 [3,4,2] 选择，有边界可以从 [2,5,9] 中选择，可以构成 3 * 3 个子数组。

而寻找这样一个范围，实际上需要找的是左边第一个比 2 小的元素，和右边第一个比 2 小的元素，这两个元素决定了 2 作为最小值的范围。

而选寻找下一个最小值，往往可以用单调递减栈实现。

所以，实现思路是：
- 利用单调递减栈，找到每个元素，左边第一个更小值和右边第一个更小值的下标，从而直到每个元素作为最小值的影响范围
- 遍历一次数组，累计每个元素作为最小值的子数组的和

* 参考
- [[https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1164006/xiao-bai-lang-dong-hua-xiang-jie-bao-zhe-489q/][【超小白】动画详解保证教会你这道题]]
- [[https://taxodium.ink/post/monotone-stack/][单调栈]]
