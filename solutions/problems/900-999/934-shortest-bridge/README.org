* 思路
涉及到矩阵， =最短= 路径，题做得多的话，容易想得到可能和深度优先遍历，广
度有先遍历有关，还有编号进行区分的方法。

找最短路径，比较适合用广度优先遍历。

可以先通过遍历矩阵，用 DFS 或者 BFS 找到第一个岛屿，然后编号为其他值
（非 1 的其他值），然后从这个岛屿开始，用 BFS 进行扩散遍历，记录遍历次
数（距离），当找到为 1 的格子时，就碰到了另一个岛屿，此时的距离即为最
短距离。

* 参考
- [[https://leetcode.cn/problems/shortest-bridge/solutions/1922327/-by-muse-77-j7w5/][【爪哇缪斯】图解LeetCode]]
