这道题是算二进制数字中包含了多少个 1，针对 32 位的，因此很容易想到就是位运算。

只要把数字不断右移，判断右移出去的数字是不是 1，是就统计数量，不是就继续右移，
直到数字移完 32 位即可。

但是，如果是移动数字，当数字是负数时，最左边的位就是符号位 1，每次右移，由于是
带符号的，右移之后最左边还是 1，如果是通过判断数字右移结束变为 0 作为结束条件，
就会进入死循环。

那换个思路，取一个 flag，每次左移去和数字进行与操作，判断数字的每一位是不是 1，
由于左移不涉及符号问题，就可以避免数字是负数的问题了。这种方法，需要遍历次数是
数字的二进制的位数，在本题中就是 32 位。

那能不能减少遍历次数呢？

二进制是 0，1 表示的，那如果把一个数字加 1 或者 减 1 会发生什么呢? 考虑到需要一个
结束循环的条件，可以把数字一直减 1，直到变为 0。


假如数字 1100:

1100 - 1 = 1011 (左数第二位的 1 变为 0， 右边取反，左边不变)
1011 - 1 = 1010 (最后一位 1 变为 0，左边不变)

可以看到，减 1 的时候，数字的最后一个 1 会变为 0，它之后的位会取反，它之前的位不变。

此时，把减 1 后的数字和原数字进行与运算:

1100 & 1011 = 1000 (1100 的最后一个 1 变为了 0)
1011 & 1010 = 1010 (1011 的最后一个 1 变为了 0)

可以得到一个结论: *数字减 1 后的值和数字进行与操作，会把最后一位 1 变为 0*.

利用这个性质，对数字不断减 1 然后进行与操作，就会把数字的 1 不断变为 0，最后
数字的所有 1 都会变成 0。那执行了几次循环，就相当于有多少个 1 了。
