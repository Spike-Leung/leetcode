* 思路
  由于出现 key，value，应该想到使用哈希表，这样可以在 O(1) 时间根据 key 取到 value。

  根据题目，元素的插入，访问是有先后顺序的，因此要考虑使用输入输出带有顺序的数据结构，例如栈，队列，链表。

  根据题目要求，当一个元素被访问时，需要将它放到头部。要方便的移动元素，就可以考虑链表。
  而且当缓存容量满了(大于 capacity) 需要把最后的元素移除，因此，最好用双向链表，可以很方便的找到头尾的节点。

  另外，put 要在 O(1) 时间更新元素，如果是遍历链表时间肯定不满足。但哈希表能做到 O(1) 时间找到 key，因此，
  哈希表的 key 就是元素的 key，value 则是这个元素对应的链表节点。这样就可以通过哈希表的 key 定位到节点。

  节点删除时，也许要把哈希表的 key 移除，因此节点出了存储值(value), 也要存储 key，但删除节点时，可以快读找到要删除的 key。

  因此，需要实现一个双向链表，以及对双向链表的几个操作：节点添加到头，移除尾部节点，移动节点到头部，移除节点。

  哈希表则存储 key 和都应的节点，根据 LRU 算法，get 操作时，把访问的节点放到最前面。
  put 操作时，如果超出 capacity 则移除尾部节点；如果节点存在则更新节点；节点不存在则插入到头部。

* 参考
  - [[https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/][LRU缓存机制]]
