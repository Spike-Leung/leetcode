* 思路
  根据题意，可以对数组进行轮调，把前面的一个数字放到后面去。

  得分的规则是，当前的值不大于它的下标。而当轮调的时候，可以发现，一个数往前移动，
  下标是慢慢变小的，最终到了头，被放到尾，下标又会变大。

  在轮调过程中，每个数都有 n 种下标可能，但只有某些下标，对于这个数而言是可以得分的。

  也就是说，对于一个数而言，在某个下标范围内，能够得分，而其他范围无法得分。

  下标的范围，取决于轮调的次数。那么，是否可以找到每一个数得分的下标范围？

  而找下标范围，相当于找每个数可以得分的轮调次数范围。

  统计每个数，可以得分的轮调范围，以及这些轮调范围被选择的次数，被选择次数最多的，也就是最合适的轮调范围。

  例如对于 nums[i] , 轮调 1,2,3,4 次都可以得分，对于 nums[i + 1] 轮调 4 次才可以得分。

  那么轮调四次，可以得到 2 分，因此最好的轮调次数就是 4。

  接下来，去计算每个数的轮调得分范围。

  对一个数 num[i], 数组长度为 n， 假设轮调次数为 k，那么下标范围就是 i - k

  i - k 有可能小于 0，此时就会被放到尾部，可以取模计算在后面的位置，即 (i - k + n) % n

  由于下标的取值范围是 [0, n - 1] 所以， 0 <= i - k <= n - 1
  可以得到 k 的取值范围 k <= i , k >= i - (n - 1)
  同时，要想得分，数字要小于等于下标， num[i] <= i - k, 所以还有 k <= i - nums[i]
  由于 nums[i] 取值范围是 [0, n), 所以 k <= i - nums[i] <= i, 题目要返回最小的轮调次数，因此应该满足 k <= i - nums[i]

  于是得到 k 的取值范围 [i - (n - 1), i - nums[i]] (都将他们加 n，并且取模 n，转换成正数), 将它看成 [A, B]

  如果 A < B，则意味着 [A, B] 这个轮调范围内，nums[i] 可以得分的轮调范围
  如果 A > B, 则意味着 A 被轮调到了 B 的后面，此时 [A, B] 等价于 [0, B], [A, n - 1]

  根据以上分析，对每个数，统计可以得分的轮调范围被选择的次数，

  例如对于 nums[i], 统计其可得分的轮调范围 [A, B] 被选择的次数，
  nums[i + 1] 统计 [A1, B1] 的次数

  例如对于 nums[1] 可以得分的轮调范围为 [1, 3], 也就是说轮调 1，2，3 次都能够得分，
  此时，轮调 1 次可以得一分，轮调 2 次可以得一分...

  对于 nums[2]， 可以轮调得分的范围是 [2, 3]，此时，轮调 1 次可以总共有一分，轮调 2 次有两分，轮调 3 次，也有 2分。

  此时，轮调 2 次或者 3次，分数是最高的，选小的一个，也就是轮调 2 次是最佳。

  通过不断的统计，可以得到一个轮调得分 diff, diff[i] 表示，对所有数轮调 i 次，可以得到的总分。

  取 diff[i] 最大者，且 i 尽可能小者，就是答案。

  当要统计 diff 时，需要给某个范围的 diff 加减数值，此时可以用 差值数组去实现, 在 O(1) 时间内完成加减操作。

* 参考
  - [[https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/solution/gong-shui-san-xie-shang-xia-jie-fen-xi-c-p6kh/][上下界分析 + 差分应用]]
  - [[https://labuladong.gitee.io/algo/2/22/57/][小而美的算法技巧：差分数组]]
