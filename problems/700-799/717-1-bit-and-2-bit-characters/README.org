* 思路
** 正向遍历
   字符只有两种，单纯一个 0，或者 1 开头的 10，11，那么正向扫描一次，如果是 0，
   则跳过当前数字，如果是 1 则跳过两个数字，直到遍历结束。如果最后只剩下一个 0，
   就是 true，否则为 false
** 反向遍历
   正序扫描需要扫描整个数组，既然正序可以，那么逆序是否可以呢？

   由于结尾肯定是 0，而形成1 bit 还是 2 bit，取决于 0 之前能剩下多少个 1，如果一个都不剩，
   那么最后只能是输出 1 bit 的 0。如果最后还剩下一个 1，那就形成 2 bit 的 10.

   最后一个 0 之前能剩下多少个 1，主要看最后一个 0 之前有多少个 *连续的* 1，假设有 n 个连续的 1，

   如果 n 为偶数，则这些连续的 1，恰好两两组成 2 bit 字符，最后就只剩下最后的那个 0.

   如果 n 为奇数，则这些连续的 1，最终会剩下 1 个 1，和最后的 0，形成 2 bit 的 10.

   只要判断连续的 1 的个数的奇偶性，就可以判断最后是组成 1 bit 还是 2 bit 了
* 参考
  - [[https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/1bi-te-yu-2bi-te-zi-fu-by-leetcode-solut-rhrh/][1比特与2比特字符]]
